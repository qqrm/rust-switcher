name: Release
run-name: "Release on ${{ github.ref_name }} bump ${{ inputs.bump }} | bump_tag=${{ inputs.do_bump_and_tag }} crates=${{ inputs.do_publish_crates }} github=${{ inputs.do_github_release }}"

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type (used only when do_bump_and_tag=true)"
        type: choice
        required: true
        default: patch
        options:
          - patch
          - minor
          - major

      do_bump_and_tag:
        description: "Step 1 (Linux): bump version, commit, create tag, push to main"
        type: boolean
        required: true
        default: true

      do_publish_crates:
        description: "Step 2 (Linux): publish to crates.io (uses tag ref)"
        type: boolean
        required: true
        default: true

      do_github_release:
        description: "Steps 3-4: build Linux archive + publish GitHub Release (uses tag ref)"
        type: boolean
        required: true
        default: true

      existing_tag:
        description: "Existing tag to use when do_bump_and_tag=false (example v1.2.3)"
        type: string
        required: false
        default: ""

permissions:
  contents: write

concurrency:
  group: release
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  bump_and_tag:
    name: "Step 1 - bump version and create tag on main (Linux)"
    runs-on: ubuntu-latest
    if: ${{ inputs.do_bump_and_tag }}

    outputs:
      tag: ${{ steps.version.outputs.tag }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Verify main branch
        if: ${{ github.ref != 'refs/heads/main' }}
        shell: bash
        run: |
          echo "Release workflow must be run on main branch when do_bump_and_tag=true. Current ref: $GITHUB_REF" >&2
          exit 1

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust toolchain (rust-toolchain.toml)
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Cache Rust build (cargo, target)
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: release

      - name: Verify nightly toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustc -Vv
          if ! rustc -Vv | grep -q "release:.*nightly"; then
            echo "Expected nightly toolchain from rust-toolchain.toml, but rustc -Vv does not show nightly." >&2
            exit 1
          fi

      - name: Bump version, update lock, compute tag
        id: version
        shell: bash
        env:
          BUMP: ${{ inputs.bump }}
          PACKAGE_NAME: rust-switcher
        run: |
          set -euo pipefail

          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is required on runner to parse cargo metadata" >&2
            exit 1
          fi

          git fetch --tags --force

          meta_file="$(mktemp)"
          cargo metadata --no-deps --format-version 1 > "$meta_file"

          current="$(jq -r --arg name "$PACKAGE_NAME" '.packages[] | select(.name == $name) | .version' "$meta_file")"
          if [ -z "$current" ] || [ "$current" = "null" ]; then
            echo "Failed to find package version in cargo metadata. package=$PACKAGE_NAME" >&2
            cat "$meta_file" >&2
            exit 1
          fi
          if ! echo "$current" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Current version is not semver X.Y.Z: $current" >&2
            exit 1
          fi

          latest_tag="$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)"
          if [ -n "$latest_tag" ]; then
            latest="${latest_tag#v}"
          else
            latest="0.0.0"
          fi

          parse_semver() {
            local v="$1"
            IFS='.' read -r a b c <<<"$v"
            echo "${a:-0} ${b:-0} ${c:-0}"
          }

          semver_gt() {
            local ax ay az bx by bz
            read -r ax ay az <<<"$(parse_semver "$1")"
            read -r bx by bz <<<"$(parse_semver "$2")"
            if [ "$ax" -ne "$bx" ]; then [ "$ax" -gt "$bx" ]; return; fi
            if [ "$ay" -ne "$by" ]; then [ "$ay" -gt "$by" ]; return; fi
            [ "$az" -gt "$bz" ]
          }

          bump_semver() {
            local v="$1" kind="$2"
            local x y z
            read -r x y z <<<"$(parse_semver "$v")"
            case "$kind" in
              major) x=$((x+1)); y=0; z=0 ;;
              minor) y=$((y+1)); z=0 ;;
              patch) z=$((z+1)) ;;
              *) echo "Unexpected bump kind: $kind" >&2; exit 1 ;;
            esac
            echo "$x.$y.$z"
          }

          base="$latest"
          if semver_gt "$current" "$latest"; then
            base="$current"
          fi

          next="$(bump_semver "$base" "$BUMP")"
          tag="v$next"

          if git rev-parse -q --verify "refs/tags/$tag" >/dev/null; then
            echo "Tag already exists locally after fetch: $tag" >&2
            exit 1
          fi

          tmp="$(mktemp)"
          awk -v newver="$next" '
            BEGIN{in_pkg=0;done=0}
            /^\[package\]$/ {in_pkg=1; print; next}
            /^\[[^]]+\]$/ {in_pkg=0; print; next}
            in_pkg && !done && $0 ~ /^[[:space:]]*version[[:space:]]*=/ {
              print "version = \"" newver "\""
              done=1
              next
            }
            {print}
            END{
              if(!done){
                print "version field not found in [package]" > "/dev/stderr"
                exit 2
              }
            }
          ' Cargo.toml > "$tmp"
          mv "$tmp" Cargo.toml

          cargo generate-lockfile

          if [ -z "$(git diff --name-only -- Cargo.toml)" ]; then
            echo "Version bump produced no Cargo.toml change for version=$next" >&2
            exit 1
          fi

          echo "version=$next" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Configure git identity
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Commit release changes
        shell: bash
        run: |
          set -euo pipefail
          git add Cargo.toml Cargo.lock
          if git diff --cached --quiet; then
            echo "No changes to commit after version bump. version=${{ steps.version.outputs.version }} tag=${{ steps.version.outputs.tag }}" >&2
            exit 1
          fi
          git commit -m "release: ${{ steps.version.outputs.tag }}"

      - name: Create tag locally
        shell: bash
        run: |
          set -euo pipefail
          git tag "${{ steps.version.outputs.tag }}"

      - name: Push commit and tag to origin
        shell: bash
        run: |
          set -euo pipefail
          git push --atomic origin HEAD:main "${{ steps.version.outputs.tag }}"

  determine_tag:
    name: Determine tag to use
    runs-on: ubuntu-latest
    needs: bump_and_tag
    if: ${{ always() && (inputs.do_bump_and_tag || inputs.existing_tag != '') }}

    outputs:
      tag: ${{ steps.resolve.outputs.tag }}

    steps:
      - name: Resolve tag
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          if [ "${{ inputs.do_bump_and_tag }}" = "true" ]; then
            if [ "${{ needs.bump_and_tag.result }}" != "success" ]; then
              echo "bump_and_tag did not succeed, cannot proceed" >&2
              exit 1
            fi
            echo "tag=${{ needs.bump_and_tag.outputs.tag }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          tag="${{ inputs.existing_tag }}"
          if [ -z "$tag" ]; then
            echo "existing_tag is required when do_bump_and_tag=false" >&2
            exit 1
          fi
          if ! echo "$tag" | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "existing_tag must look like v1.2.3, got: $tag" >&2
            exit 1
          fi

          echo "tag=$tag" >> "$GITHUB_OUTPUT"

  publish_crates:
    name: "Step 2 - publish to crates.io (tag ref)"
    runs-on: ubuntu-latest
    needs: determine_tag
    if: ${{ inputs.do_publish_crates }}

    steps:
      - name: Checkout at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_tag.outputs.tag }}
          fetch-depth: 0

      - name: Setup Rust toolchain (rust-toolchain.toml)
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Cache Rust build (cargo, target)
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: release

      - name: Verify nightly toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustc -Vv
          if ! rustc -Vv | grep -q "release:.*nightly"; then
            echo "Expected nightly toolchain from rust-toolchain.toml, but rustc -Vv does not show nightly." >&2
            exit 1
          fi

      - name: Publish to crates.io (no verify)
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          cargo publish --locked --no-verify

  build_windows_gnu_asset:
    name: "Step 3 - build and package Windows (GNU) archive on Linux (tag ref)"
    runs-on: ubuntu-latest
    needs: determine_tag
    if: ${{ inputs.do_github_release }}

    outputs:
      asset: ${{ steps.package.outputs.asset }}

    steps:
      - name: Checkout at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_tag.outputs.tag }}

      - name: Setup Rust toolchain (rust-toolchain.toml)
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Cache Rust build (cargo, target)
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: release

      - name: Verify nightly toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustc -Vv
          if ! rustc -Vv | grep -q "release:.*nightly"; then
            echo "Expected nightly toolchain from rust-toolchain.toml, but rustc -Vv does not show nightly." >&2
            exit 1
          fi

      - name: Install Windows GNU toolchain
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y mingw-w64 zip
          rustup target add x86_64-pc-windows-gnu

      - name: Build (locked, Windows GNU target)
        shell: bash
        run: |
          set -euo pipefail
          cargo build -p rust-switcher --release --locked --target x86_64-pc-windows-gnu

      - name: Package zip
        id: package
        shell: bash
        env:
          PACKAGE_NAME: rust-switcher
        run: |
          set -euo pipefail

          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is required on runner to parse cargo metadata" >&2
            exit 1
          fi

          meta_file="$(mktemp)"
          cargo metadata --no-deps --format-version 1 > "$meta_file"

          version="$(jq -r --arg name "$PACKAGE_NAME" '.packages[] | select(.name == $name) | .version' "$meta_file")"
          if [ -z "$version" ] || [ "$version" = "null" ]; then
            echo "Failed to find package version in cargo metadata. package=$PACKAGE_NAME" >&2
            cat "$meta_file" >&2
            exit 1
          fi
          if ! echo "$version" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Failed to get semver from cargo metadata: $version" >&2
            exit 1
          fi

          asset="rust-switcher-$version-windows-x86_64-gnu.zip"
          install -m 0755 target/x86_64-pc-windows-gnu/release/rust-switcher.exe ./rust-switcher.exe
          zip -9 "$asset" rust-switcher.exe
          echo "asset=$asset" >> "$GITHUB_OUTPUT"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-gnu-asset
          path: ${{ steps.package.outputs.asset }}
          if-no-files-found: error

  github_release:
    name: "Step 4 - publish GitHub Release (tag ref)"
    runs-on: ubuntu-latest
    needs: [determine_tag, build_windows_gnu_asset, publish_crates]
    if: ${{ inputs.do_github_release }}

    steps:
      - name: Download Windows GNU asset
        uses: actions/download-artifact@v4
        with:
          name: windows-gnu-asset
          path: .
          merge-multiple: true

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.determine_tag.outputs.tag }}
          name: ${{ needs.determine_tag.outputs.tag }}
          files: |
            "*.tar.gz"
            "*.zip"
